<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SM64 Mobile Single Star Records</title>
    <style>
        :root { --bg-color: #121212; --text-color: #e0e0e0; --primary-color: #ffffff; --secondary-color: #b3b3b3; --border-color: #333333; --pending-color: #f39c12; --accent-color: #6200ee; --rejected-color: #e74c3c; }
        body { background-color: var(--bg-color); color: var(--text-color); font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif; margin: 0; padding: 1rem; }
        header { text-align: center; border-bottom: 1px solid var(--border-color); padding-bottom: 1rem; margin-bottom: 1.5rem; }
        h1, h2, h3 { color: var(--primary-color); }
        nav { margin-top: 1rem; display: flex; justify-content: center; gap: 1.5rem; flex-wrap: wrap; }
        nav a, .action-button { color: var(--secondary-color); text-decoration: none; font-weight: bold; cursor: pointer; }
        nav a:hover, .action-button:hover { color: var(--primary-color); }
        main { max-width: 900px; margin: 0 auto; }
        .grid-container { display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 1rem; }
        .card { background-color: #1e1e1e; border: 1px solid var(--border-color); border-radius: 8px; padding: 1.5rem; text-align: center; cursor: pointer; transition: transform 0.2s; }
        .card:hover { transform: translateY(-5px); }
        .table-container { overflow-x: auto; }
        table { width: 100%; border-collapse: collapse; }
        th, td { padding: 0.75rem; text-align: left; border-bottom: 1px solid var(--border-color); }
        .mod-actions { display: flex; gap: 5px; align-items: center; white-space: nowrap; }
        .mod-actions button { background: none; border: 1px solid var(--border-color); color: var(--text-color); cursor: pointer; padding: 4px 8px; border-radius: 4px; font-size: 1rem; line-height: 1; }
        .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.7); justify-content: center; align-items: center; }
        .modal-content { background-color: #2a2a2a; padding: 2rem; border-radius: 8px; width: 90%; max-width: 500px; position: relative; max-height: 90vh; overflow-y: auto; }
        .close-btn { position: absolute; top: 10px; right: 15px; font-size: 1.5rem; cursor: pointer; }
        form label { display: block; margin-top: 1rem; }
        .visually-hidden { position: absolute; width: 1px; height: 1px; margin: -1px; padding: 0; overflow: hidden; clip: rect(0, 0, 0, 0); border: 0; }
        form input, form select, form button { width: 100%; padding: 0.75rem; margin-top: 0.5rem; border-radius: 4px; border: 1px solid var(--border-color); background-color: #333; color: var(--text-color); box-sizing: border-box; }
        form button { background-color: var(--accent-color); font-weight: bold; cursor: pointer; }
        form button:disabled { background-color: #555; cursor: not-allowed; }
        .loader { text-align: center; font-size: 1.2em; padding: 2rem; }
        .breadcrumb { margin-bottom: 1rem; font-size: 1.1em; }
        .breadcrumb a { color: var(--secondary-color); }
        .breadcrumb span { color: var(--primary-color); }
        #mod-queue-container td { vertical-align: middle; }
        .wr-list { font-size: 0.9em; color: var(--secondary-color); list-style-type: none; padding-left: 0; }
        .error-message { color: var(--rejected-color); margin-top: 1rem; display: none; }
        
        .form-row { display: flex; gap: 0.5rem; }
        .form-row input { margin-top: 0.5rem; }
        #submission-form input, #submission-form select { margin-top: 0.5rem; }

        @media (max-width: 600px) {
            body { padding: 0.5rem; }
            h1 { font-size: 1.5rem; }
            h2 { font-size: 1.3rem; }
            .card h3 { font-size: 1.1rem; }
            td, th { padding: 0.5rem; }
        }
    </style>
</head>
<body>
    <header>
        <h1>SM64 Mobile - Single Star Records</h1>
        <nav>
            <a href="#home">Courses</a>
            <a href="#worldrecords">World Records</a>
            <a href="#wrhistory">WR History</a>
            <span id="mod-queue-link-container"></span>
        </nav>
        <div id="user-actions" style="margin-top: 1rem;">
            <a class="action-button" onclick="openSubmissionModal()">Submit Run</a>
            <span style="color: var(--border-color); margin: 0 10px;">|</span>
            <a href="#minigames" class="action-button">Minigames</a>
            <span style="color: var(--border-color); margin: 0 10px;">|</span>
            <span id="moderator-auth-section"></span>
        </div>
    </header>
    <main id="app-container"></main>

    <div id="submission-modal" class="modal">
        <div class="modal-content">
            <span class="close-btn" onclick="closeModal('submission-modal')">&times;</span>
            <h2>Submit New Run</h2>
            <form id="submission-form" onsubmit="handleRunSubmission(event)">
                <select id="course-select" required><option value="">Select a Course</option></select>
                <select id="star-select" required disabled><option value="">Select a Star</option></select>
                <input type="text" id="runner" required placeholder="Runner Name">
                <div class="form-row">
                    <input type="text" id="igt" required placeholder="In-Game Time (IGT)">
                    <input type="text" id="rta" placeholder="Real Time (RTA) (Optional)">
                </div>
                <label for="date" class="visually-hidden">Date of the Run</label>
                <input type="date" id="date" required title="Date of the Run">
                <input type="url" id="videoLink" required placeholder="Video Link (e.g., https://youtu.be/...)">
                <button type="submit" id="submit-run-button">Submit Run</button>
            </form>
        </div>
    </div>
    <div id="edit-run-modal" class="modal">
        <div class="modal-content">
            <span class="close-btn" onclick="closeModal('edit-run-modal')">&times;</span>
            <h2>Edit Run</h2>
            <form id="edit-run-form" onsubmit="handleRunUpdate(event)">
                <input type="hidden" id="edit-run-id"><input type="hidden" id="edit-course-id"><input type="hidden" id="edit-star-id">
                <label for="edit-runner">Runner:</label><input type="text" id="edit-runner" required>
                <label for="edit-igt">In-Game Time (IGT):</label><input type="text" id="edit-igt" required>
                <label for="edit-rta">Real Time (RTA):</label><input type="text" id="edit-rta">
                <label for="edit-date">Date:</label><input type="date" id="edit-date" required>
                <label for="edit-videoLink">Video Link:</label><input type="url" id="edit-videoLink" required>
                <button type="submit" id="update-run-button">Update Run</button>
            </form>
        </div>
    </div>
     <div id="login-modal" class="modal">
        <div class="modal-content">
            <span class="close-btn" onclick="closeModal('login-modal')">&times;</span>
            <h2>Moderator Login</h2>
            <form id="login-form" onsubmit="handleLogin(event)">
                <label for="email">Email:</label>
                <input type="email" id="email" required>
                <label for="password">Password:</label>
                <input type="password" id="password" required>
                <button type="submit">Log In</button>
                <p id="login-error" class="error-message"></p>
            </form>
        </div>
    </div>

    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-firestore.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>

    <script>
        // ==============================================================================
        // --- 1. CONFIG & APP STATE ---
        // ==============================================================================
        const firebaseConfig = {
            apiKey: "AIzaSyCHGM4Bw4w-3SM3ScVCLnLhcCI0ISTB7S0",
            authDomain: "sm64-mobile-leaderboard.firebaseapp.com",
            projectId: "sm64-mobile-leaderboard",
            storageBucket: "sm64-mobile-leaderboard.firebasestorage.app",
            messagingSenderId: "474371344168",
            appId: "1:474371344168:web:a888b644a2a0b04ec9f21d"
        };
        
        firebase.initializeApp(firebaseConfig);
        const db = firebase.firestore();
        const auth = firebase.auth();

        const appContainer = document.getElementById('app-container');
        const appState = {
            isModerator: false,
            coursesCache: [],
            starsCache: {},
            currentListener: null,
        };

        // ==============================================================================
        // --- 2. ROUTER & NAVIGATION ---
        // ==============================================================================
        function router() {
            if (appState.currentListener) {
                appState.currentListener();
                appState.currentListener = null;
            }

            const hash = window.location.hash || '#home';
            if (hash === '#home') {
                showCoursesPage();
            } else if (hash.startsWith('#course/')) {
                const courseId = hash.substring('#course/'.length);
                showStarsPage(courseId);
            } else if (hash.startsWith('#star/')) {
                const [courseId, starId] = hash.substring('#star/'.length).split('/');
                showLeaderboard(courseId, starId);
            } else if (hash === '#modqueue') {
                showModQueuePage();
            } else if (hash === '#worldrecords') {
                showWorldRecordsPage();
            } else if (hash === '#wrhistory') {
                showWRHistoryPage();
            } else if (hash === '#minigames') {
                showMinigamesPage();
            } else {
                window.location.hash = '#home';
            }
        }
        
        // ==============================================================================
        // --- 3. RENDER FUNCTIONS ---
        // ==============================================================================
        function renderLoader(message) { appContainer.innerHTML = `<div class="loader">${message}</div>`; }
        function renderError(message) { appContainer.innerHTML = `<h2>${message}</h2>`; }

        async function loadCourses() {
            if (appState.coursesCache.length > 0) return appState.coursesCache;
            try {
                const snapshot = await db.collection('courses').orderBy('order').get();
                appState.coursesCache = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                return appState.coursesCache;
            } catch (error) { console.error(error); renderError("Error connecting to the database."); return []; }
        }

        async function loadStarsForCourse(courseId) {
            if (appState.starsCache[courseId]) return appState.starsCache[courseId];
             try {
                const snapshot = await db.collection('courses').doc(courseId).collection('stars').orderBy('order').get();
                const stars = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                appState.starsCache[courseId] = stars;
                return stars;
            } catch (error) { console.error(error); renderError("Could not load stars for this course."); return []; }
        }
        
        async function showCoursesPage() {
            renderLoader("Loading Courses...");
            const courses = await loadCourses();
            if (courses.length === 0) {
                renderError('No courses found. Please run `seedDatabase()` in the console (F12) to populate data.');
                return;
            }
            appContainer.innerHTML = `
                <h2>Select a Course</h2>
                <div class="grid-container">
                    ${courses.map(course => `
                        <div class="card" onclick="window.location.hash='#course/${course.id}'">
                            <h3>${course.name}</h3>
                        </div>
                    `).join('')}
                </div>`;
        }
        
        async function showStarsPage(courseId) {
            renderLoader("Loading Stars...");
            await loadCourses();
            const course = appState.coursesCache.find(c => c.id === courseId);
            if (!course) { window.location.hash = '#home'; return; }

            const stars = await loadStarsForCourse(courseId);
            appContainer.innerHTML = `
                <div class="breadcrumb"><a href="#home">Courses</a> / <span>${course.name}</span></div>
                <h2>Select a Star</h2>
                <div class="grid-container">
                    ${stars.map(star => `
                        <div class="card" onclick="window.location.hash='#star/${course.id}/${star.id}'">
                            <h3>${star.name}</h3>
                        </div>
                    `).join('')}
                </div>`;
        }

        async function showLeaderboard(courseId, starId) {
            renderLoader("Loading Leaderboard...");
            await loadCourses();
            await loadStarsForCourse(courseId);
            const course = appState.coursesCache.find(c => c.id === courseId);
            const star = appState.starsCache[courseId]?.find(s => s.id === starId);

            if (!course || !star) { window.location.hash = '#home'; return; }

            const runsCollection = db.collection('courses').doc(courseId).collection('stars').doc(starId).collection('runs')
                .where('status', '==', 'verified').orderBy('igt_numeric');

            appState.currentListener = runsCollection.onSnapshot(snapshot => {
                const runs = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                appContainer.innerHTML = `
                    <div class="breadcrumb">
                        <a href="#home">Courses</a> / <a href="#course/${course.id}">${course.name}</a> / <span>${star.name}</span>
                    </div>
                    <h2>${star.name} Leaderboard</h2>
                    <div class="table-container">
                        <table>
                            <thead><tr><th>#</th><th>Runner</th><th>IGT</th><th>RTA</th><th>Date</th><th>Video</th>${appState.isModerator ? '<th>Actions</th>' : ''}</tr></thead>
                            <tbody>
                            ${runs.map((run, index) => {
                                const runDate = run.date ? new Date(run.date.replace(/-/g, '\/')).toLocaleDateString() : 'N/A';
                                return `<tr>
                                    <td>${index + 1}</td>
                                    <td>${run.runner}</td>
                                    <td>${run.igt_str || 'N/A'}</td>
                                    <td>${run.rta_str || 'N/A'}</td>
                                    <td>${runDate}</td>
                                    <td><a href="${run.videoLink}" target="_blank" rel="noopener noreferrer">Link</a></td>
                                    ${appState.isModerator ? `
                                        <td><div class="mod-actions">
                                            <button onclick="openEditModal('${courseId}', '${starId}', '${run.id}')" title="Edit">✏️</button>
                                            <button onclick="deleteRun('${courseId}', '${starId}', '${run.id}')" title="Delete">🗑️</button>
                                        </div></td>` : ''}
                                </tr>`;
                            }).join('') || '<tr><td colspan="7">No verified runs submitted yet.</td></tr>'}
                            </tbody>
                        </table>
                    </div>`;
            }, error => {
                console.error("Error fetching leaderboard:", error);
                renderError("Failed to load leaderboard.");
            });
        }
        
        async function showModQueuePage() {
            if (!appState.isModerator) { window.location.hash = '#home'; return; }
            renderLoader("Loading Moderation Queue...");
            await loadCourses();

            try {
                const pendingRunsSnapshot = await db.collectionGroup('runs').where('status', '==', 'pending').get();
                const pendingRuns = pendingRunsSnapshot.docs.map(doc => {
                    const path = doc.ref.path.split('/');
                    return { id: doc.id, courseId: path[1], starId: path[3], ...doc.data() };
                });

                for (const run of pendingRuns) {
                    if (!appState.starsCache[run.courseId]) { await loadStarsForCourse(run.courseId); }
                }

                appContainer.innerHTML = `
                    <h2>Moderation Queue</h2>
                    <div id="mod-queue-container" class="table-container">
                        <table>
                            <thead><tr><th>Runner</th><th>Course / Star</th><th>IGT</th><th>RTA</th><th>Video</th><th>Actions</th></tr></thead>
                            <tbody>
                                ${pendingRuns.map(run => {
                                    const course = appState.coursesCache.find(c => c.id === run.courseId);
                                    const star = appState.starsCache[run.courseId]?.find(s => s.id === run.starId);
                                    return `
                                        <tr>
                                            <td>${run.runner}</td>
                                            <td>${course?.name || run.courseId} /<br>${star?.name || run.starId}</td>
                                            <td>${run.igt_str}</td>
                                            <td>${run.rta_str || 'N/A'}</td>
                                            <td><a href="${run.videoLink}" target="_blank">Link</a></td>
                                            <td><div class="mod-actions">
                                                <button onclick="updateRunStatus('${run.courseId}', '${run.starId}', '${run.id}', 'verified')" title="Verify">✅</button>
                                                <button onclick="updateRunStatus('${run.courseId}', '${run.starId}', '${run.id}', 'rejected')" title="Reject">❌</button>
                                                <button onclick="openEditModal('${run.courseId}', '${run.starId}', '${run.id}')" title="Edit">✏️</button>
                                                <button onclick="deleteRun('${run.courseId}', '${run.starId}', '${run.id}')" title="Delete">🗑️</button>
                                            </div></td>
                                        </tr>`;
                                }).join('') || '<tr><td colspan="6">The moderation queue is empty.</td></tr>'}
                            </tbody>
                        </table>
                    </div>`;
            } catch (error) {
                console.error("Error loading mod queue:", error);
                renderError("Failed to load moderation queue. You may need to create a Firestore index. Check the console (F12) for an error message with a link to create it.");
            }
        }
        
        async function showWorldRecordsPage() {
            renderLoader("Calculating World Records...");
            try {
                await loadCourses();
                const allRunsSnapshot = await db.collectionGroup('runs').where('status', '==', 'verified').get();
                
                const stars = {};
                allRunsSnapshot.forEach(doc => {
                    const run = doc.data();
                    const path = doc.ref.path.split('/');
                    const key = `${path[1]}/${path[3]}`;
                    if (!stars[key]) stars[key] = { runs: [], courseId: path[1], starId: path[3] };
                    stars[key].runs.push(run);
                });

                const wrData = {};
                for (const key in stars) {
                    const starInfo = stars[key];
                    if (starInfo.runs.length > 0) {
                        starInfo.runs.sort((a, b) => a.igt_numeric - b.igt_numeric);
                        const originalRunnerName = starInfo.runs[0].runner;
                        
                        const normalizedKey = originalRunnerName.toLowerCase().trim();

                        if (!appState.starsCache[starInfo.courseId]) { await loadStarsForCourse(starInfo.courseId); }
                        const starName = appState.starsCache[starInfo.courseId]?.find(s => s.id === starInfo.starId)?.name || starInfo.starId;

                        if (!wrData[normalizedKey]) {
                            wrData[normalizedKey] = { displayName: originalRunnerName, count: 0, stars: [] };
                        }
                        wrData[normalizedKey].count++;
                        wrData[normalizedKey].stars.push(starName);
                    }
                }

                const sortedWRs = Object.values(wrData).sort((a, b) => b.count - a.count);

                appContainer.innerHTML = `
                    <h2>World Records Tally</h2>
                    <div class="table-container">
                        <table>
                            <thead><tr><th>#</th><th>Runner</th><th>WRs</th><th>Stars</th></tr></thead>
                            <tbody>
                                ${sortedWRs.map((data, index) => `
                                    <tr>
                                        <td>${index + 1}</td>
                                        <td>${data.displayName}</td>
                                        <td>${data.count}</td>
                                        <td><ul class="wr-list">${data.stars.sort().map(s => `<li>${s}</li>`).join('')}</ul></td>
                                    </tr>
                                `).join('') || '<tr><td colspan="4">No world records found.</td></tr>'}
                            </tbody>
                        </table>
                    </div>`;
            } catch (error) {
                console.error("Error calculating world records:", error);
                renderError("Failed to calculate world records. You may need to create an index. Check the console (F12) for a link.");
            }
        }

        function showWRHistoryPage() {
            appContainer.innerHTML = `<h2>WR History</h2><p>This page is under construction.</p>`;
        }
        
        async function showMinigamesPage() {
            renderLoader("Loading Minigames...");
            try {
                const snapshot = await db.collection('minigames').orderBy('order').get();
                if (snapshot.empty) {
                    renderError("No minigame data found. Please run `seedDatabase()` from the console to add it.");
                    return;
                }

                const minigames = snapshot.docs.map(doc => doc.data());
                
                const wrCounts = {};
                minigames.forEach(mg => {
                    mg.categories.forEach(cat => {
                        if (cat.wr_holder) {
                            wrCounts[cat.wr_holder] = (wrCounts[cat.wr_holder] || 0) + 1;
                        }
                    });
                });
                const sortedWrs = Object.entries(wrCounts).sort((a,b) => b[1] - a[1]);

                let minigamesHtml = '';
                minigames.forEach(mg => {
                    minigamesHtml += `
                        <tr><td colspan="3" style="background-color: var(--border-color);"><strong>${mg.name}</strong></td></tr>
                        ${mg.categories.map(cat => `
                            <tr>
                                <td>${cat.name}</td>
                                <td>${cat.wr_holder || 'N/A'}</td>
                                <td>${cat.time || 'N/A'}</td>
                            </tr>
                        `).join('')}
                    `;
                });

                appContainer.innerHTML = `
                    <h2>Minigames</h2>
                    <div style="display: flex; flex-wrap: wrap; gap: 2rem;">
                        <div style="flex: 2; min-width: 300px;">
                            <h3>Leaderboards</h3>
                            <div class="table-container">
                                <table>
                                    <thead>
                                        <tr><th>Category</th><th>WR Holder</th><th>Time</th></tr>
                                    </thead>
                                    <tbody>${minigamesHtml}</tbody>
                                </table>
                            </div>
                        </div>
                        <div style="flex: 1; min-width: 250px;">
                            <h3>Mobile Players with Most WRs</h3>
                             <div class="table-container">
                                <table>
                                    <thead>
                                        <tr><th>#</th><th>Player</th><th>WRs</th></tr>
                                    </thead>
                                    <tbody>
                                        ${sortedWrs.map(([name, count], index) => `
                                            <tr>
                                                <td>${index + 1}</td>
                                                <td>${name}</td>
                                                <td>${count}</td>
                                            </tr>
                                        `).join('')}
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                `;
            } catch (error) {
                console.error("Error loading minigames:", error);
                renderError("Failed to load minigame data.");
            }
        }
        
        // ==============================================================================
        // --- 4. ACTIONS & MODERATION ---
        // ==============================================================================
        function updateModeratorUI(user) {
            appState.isModerator = !!user;
            const modSection = document.getElementById('moderator-auth-section');
            const modQueueLink = document.getElementById('mod-queue-link-container');

            if (user) {
                modSection.innerHTML = `<a class="action-button" onclick="logoutModerator()">Logout (${user.email})</a>`;
                modQueueLink.innerHTML = `<a href="#modqueue">Moderation Queue</a>`;
            } else {
                modSection.innerHTML = `<a class="action-button" onclick="openLoginModal()">Moderator Login</a>`;
                modQueueLink.innerHTML = '';
            }
            router();
        }

        auth.onAuthStateChanged(user => { updateModeratorUI(user); });

        async function handleLogin(event) {
            event.preventDefault();
            const form = event.target;
            const email = form.email.value;
            const password = form.password.value;
            const errorElement = document.getElementById('login-error');
            errorElement.style.display = 'none';

            try {
                await auth.signInWithEmailAndPassword(email, password);
                closeModal('login-modal');
            } catch (error) {
                console.error("Login failed:", error.message);
                errorElement.textContent = "Login failed. Please check your email and password.";
                errorElement.style.display = 'block';
            }
        }
        
        async function logoutModerator() { await auth.signOut(); }
        function openModal(modalId) { document.getElementById(modalId).style.display = 'flex'; }
        function closeModal(modalId) { document.getElementById(modalId).style.display = 'none'; }
        function openLoginModal() { openModal('login-modal'); }
        
        async function openSubmissionModal() {
            const courses = await loadCourses();
            const courseSelect = document.getElementById('course-select');
            const starSelect = document.getElementById('star-select');
            
            courseSelect.innerHTML = '<option value="">Select a Course</option>' + courses.map(c => `<option value="${c.id}">${c.name}</option>`).join('');
            starSelect.innerHTML = '<option value="">Select a Star</option>';
            starSelect.disabled = true;

            courseSelect.onchange = async () => {
                const courseId = courseSelect.value;
                if (!courseId) {
                    starSelect.innerHTML = '<option value="">Select a Star</option>';
                    starSelect.disabled = true;
                    return;
                }
                const stars = await loadStarsForCourse(courseId);
                starSelect.innerHTML = '<option value="">Select a Star</option>' + stars.map(s => `<option value="${s.id}">${s.name}</option>`).join('');
                starSelect.disabled = false;
            };
            
            openModal('submission-modal');
        }

        async function openEditModal(courseId, starId, runId) {
            if (!appState.isModerator) return;
            try {
                const runDoc = await db.collection('courses').doc(courseId).collection('stars').doc(starId).collection('runs').doc(runId).get();
                if (!runDoc.exists) { alert("Run not found!"); return; }
                const runData = runDoc.data();
                
                document.getElementById('edit-run-id').value = runId;
                document.getElementById('edit-course-id').value = courseId;
                document.getElementById('edit-star-id').value = starId;
                document.getElementById('edit-runner').value = runData.runner;
                document.getElementById('edit-igt').value = runData.igt_str || '';
                document.getElementById('edit-rta').value = runData.rta_str || '';
                document.getElementById('edit-date').value = runData.date;
                document.getElementById('edit-videoLink').value = runData.videoLink;
                
                openModal('edit-run-modal');
            } catch(error) {
                console.error("Error opening edit modal:", error);
                alert("Could not load run data for editing.");
            }
        }

        function parseTimeToNumeric(timeStr) {
            if (String(timeStr).includes(':')) {
                const parts = String(timeStr).split(':').map(Number);
                if (parts.length === 2) return (parts[0] * 60) + parts[1];
                if (parts.length === 3) return (parts[0] * 3600) + (parts[1] * 60) + parts[2];
            }
            return parseFloat(timeStr) || Infinity;
        }

        async function handleRunSubmission(event) {
            event.preventDefault();
            const form = document.getElementById('submission-form');
            const submitButton = document.getElementById('submit-run-button');
            submitButton.disabled = true;
            submitButton.textContent = 'Submitting...';

            const courseId = form['course-select'].value;
            const starId = form['star-select'].value;
            const runnerName = form.runner.value.trim();
            const igtStr = form.igt.value;
            const rtaStr = form.rta.value;
            
            const runData = {
                runner: runnerName,
                runner_normalized: runnerName.toLowerCase().trim(),
                igt_str: igtStr,
                rta_str: rtaStr || '',
                igt_numeric: parseTimeToNumeric(igtStr),
                date: form.date.value,
                videoLink: form.videoLink.value,
                status: 'pending'
            };

            const runsRef = db.collection('courses').doc(courseId).collection('stars').doc(starId).collection('runs');
            
            try {
                const existingRunSnapshot = await runsRef.where('runner_normalized', '==', runData.runner_normalized).where('status', '==', 'verified').limit(1).get();

                if (!existingRunSnapshot.empty) {
                    const existingTime = existingRunSnapshot.docs[0].data().igt_numeric;
                    if (runData.igt_numeric >= existingTime) {
                        alert("Submission failed: Your new IGT is not faster than your currently verified record.");
                        submitButton.disabled = false;
                        submitButton.textContent = 'Submit Run';
                        return;
                    }
                }
                
                await runsRef.add(runData);
                alert("Run submitted for moderation!");
                closeModal('submission-modal');
                form.reset();
            } catch (error) {
                alert("An error occurred during submission.");
                console.error("Run submission error:", error);
            } finally {
                submitButton.disabled = false;
                submitButton.textContent = 'Submit Run';
            }
        }

        async function handleRunUpdate(event) {
            event.preventDefault();
            if (!appState.isModerator) return;
            const form = event.target;
            const button = form.querySelector('button');
            button.disabled = true;
            button.textContent = 'Updating...';

            const runId = form['edit-run-id'].value;
            const courseId = form['edit-course-id'].value;
            const starId = form['edit-star-id'].value;
            const runnerName = form['edit-runner'].value;
            const igtStr = form['edit-igt'].value;
            const rtaStr = form['edit-rta'].value;
            
            const updatedData = {
                runner: runnerName,
                runner_normalized: runnerName.toLowerCase().trim(),
                igt_str: igtStr,
                rta_str: rtaStr || '',
                igt_numeric: parseTimeToNumeric(igtStr),
                date: form['edit-date'].value,
                videoLink: form['edit-videoLink'].value
            };

            try {
                await db.collection('courses').doc(courseId).collection('stars').doc(starId).collection('runs').doc(runId).update(updatedData);
                alert("Run updated successfully!");
                closeModal('edit-run-modal');
                router();
            } catch(error) {
                console.error("Run update error:", error);
                alert("Failed to update run.");
            } finally {
                button.disabled = false;
                button.textContent = 'Update Run';
            }
        }

        async function updateRunStatus(courseId, starId, runId, newStatus) {
            if (!appState.isModerator) return;
            if (!confirm(`Are you sure you want to ${newStatus} this run?`)) return;

            const runRef = db.collection('courses').doc(courseId).collection('stars').doc(starId).collection('runs').doc(runId);

            try {
                if (newStatus === 'verified') {
                    const runDoc = await runRef.get();
                    if (!runDoc.exists) throw new Error("Run not found");
                    const runData = runDoc.data();

                    const query = db.collection('courses').doc(courseId).collection('stars').doc(starId).collection('runs')
                        .where('runner_normalized', '==', runData.runner_normalized)
                        .where('status', '==', 'verified');
                    
                    const oldRunsSnapshot = await query.get();
                    
                    const batch = db.batch();
                    oldRunsSnapshot.forEach(doc => {
                        console.log(`Deleting old verified run ${doc.id} for runner ${runData.runner}`);
                        batch.delete(doc.ref);
                    });
                    
                    batch.update(runRef, { status: 'verified' });
                    await batch.commit();

                } else {
                    await runRef.update({ status: newStatus });
                }

                alert(`Run has been ${newStatus}.`);
                router();
            } catch (error) {
                console.error(`Failed to ${newStatus} run:`, error);
                alert(`An error occurred.`);
            }
        }

        async function deleteRun(courseId, starId, runId) {
            if (!appState.isModerator) return;
            if (!confirm("Are you sure you want to permanently delete this run? This cannot be undone.")) return;

            try {
                await db.collection('courses').doc(courseId).collection('stars').doc(starId).collection('runs').doc(runId).delete();
                alert("Run deleted successfully.");
                router();
            } catch (error) {
                console.error("Failed to delete run:", error);
                alert("An error occurred while deleting the run.");
            }
        }
        
        // ==============================================================================
        // --- 5. DATA MIGRATION & SEEDING ---
        // ==============================================================================
        async function migrateRuns() {
            console.log("Starting migration of old runs...");
            if(!confirm("This will update existing runs to the new RTA/IGT format. This should only be run ONCE. Continue?")) return;

            try {
                const snapshot = await db.collectionGroup('runs').get();
                const batch = db.batch();
                let updatedCount = 0;

                snapshot.forEach(doc => {
                    const runData = doc.data();
                    if ((runData.time_str || runData.time) && typeof runData.igt_str === 'undefined') {
                        const oldTime = runData.time_str || runData.time;
                        const updates = {
                            runner_normalized: runData.runner.toLowerCase().trim(),
                            igt_str: oldTime,
                            rta_str: oldTime,
                            igt_numeric: parseTimeToNumeric(oldTime),
                            time_str: firebase.firestore.FieldValue.delete(),
                            time_numeric: firebase.firestore.FieldValue.delete()
                        };
                        batch.update(doc.ref, updates);
                        updatedCount++;
                    }
                });

                if (updatedCount > 0) {
                    await batch.commit();
                    alert(`${updatedCount} runs were successfully migrated to the new format!`);
                } else {
                    alert("No runs needed migration.");
                }
                console.log("Migration complete.");
                window.location.reload();
            } catch (error) {
                console.error("Migration failed:", error);
                alert("An error occurred during migration. Check the console.");
            }
        }
        
        async function seedDatabase() {
            console.log("This will add/update data from the PDF. It will NOT delete existing user-submitted runs.");
            if (!confirm("This will add new collections and overwrite specific seed runs. Are you sure?")) return;

            const seedData = {
                minigames: [
                    {
                        name: "Princess Secret Slide",
                        order: 1,
                        categories: [
                            { name: "No Restrictions", wr_holder: null, time: null },
                            { name: "No Shortcuts", wr_holder: null, time: null },
                            { name: "80 Coins", wr_holder: null, time: null }
                        ]
                    },
                    {
                        name: "FootRace With Koopa The quick",
                        order: 2,
                        categories: [
                            { name: "No Restrictions", wr_holder: null, time: null },
                            { name: "No BLJ", wr_holder: null, time: null },
                            { name: "No Wing Cap", wr_holder: null, time: null },
                            { name: "No BLJ Or Wing Cap", wr_holder: null, time: null }
                        ]
                    },
                    {
                        name: "Rematch With Koopa The Quick",
                        order: 3,
                        categories: [
                            { name: "No Restrictions", wr_holder: null, time: null },
                            { name: "No BLJ", wr_holder: null, time: null },
                            { name: "No Shell Glitch", wr_holder: null, time: null },
                            { name: "No Shell", wr_holder: null, time: null },
                            { name: "No BLJ Or Shell Glitch", wr_holder: null, time: null },
                            { name: "No BLJ Or Shell", wr_holder: null, time: null }
                        ]
                    }
                ],
                ss_runs: [
                    { course: 'bob', star: 'footrace_with_koopa_the_quick', run: { runner: "Speedvortex", time: "1:18.88", date: "2025-08-31", videoLink: "https://youtu.be/WD3PxUUCjo" }},
                    { course: 'ccm', star: 'lil_penguin_lost', run: { runner: "Zackajin", time: "20.03", date: "2025-08-13", videoLink: "https://youtu.be/CmmiWadG53jc?feature=shared" }},
                    { course: 'ccm', star: 'big_penguin_race', run: { runner: "Zackajin", time: "48.96", date: "2025-08-13", videoLink: "https://youtu.be/EastsEGNSK?feature=shared" }}
                ]
            };
            
            try {
                console.log("Starting database seed/update...");
                const batch = db.batch();
                
                const minigamesCollection = db.collection('minigames');
                seedData.minigames.forEach(mg => {
                    const docRef = minigamesCollection.doc(mg.name.toLowerCase().replace(/\s+/g, '_'));
                    batch.set(docRef, mg, { merge: true });
                });
                
                for(const data of seedData.ss_runs) {
                    const run = data.run;
                    const formattedRun = {
                        runner: run.runner,
                        runner_normalized: run.runner.toLowerCase().trim(),
                        igt_str: run.time,
                        rta_str: run.time,
                        igt_numeric: parseTimeToNumeric(run.time),
                        date: run.date,
                        videoLink: run.videoLink,
                        status: 'verified'
                    };
                    const runsRef = db.collection('courses').doc(data.course).collection('stars').doc(data.star).collection('runs');
                    // To avoid duplicates, we check if a run by this seed user already exists
                    const existingSnapshot = await runsRef.where('runner_normalized', '==', formattedRun.runner_normalized).get();
                    if (existingSnapshot.empty) {
                        const newRunRef = runsRef.doc();
                        batch.set(newRunRef, formattedRun);
                    } else {
                        console.log(`Skipping seed for ${run.runner} on ${data.star}, as a run already exists.`);
                    }
                }

                await batch.commit();
                console.log("DATABASE SEEDING/UPDATE COMPLETE!");
                alert("New data has been added/updated successfully!");
                window.location.reload();
            } catch (error) {
                console.error("SEEDING FAILED:", error);
                alert("Seeding failed. Check the console for details.");
            }
        }
        
        // ==============================================================================
        // --- 6. INITIALIZATION ---
        // ==============================================================================
        window.addEventListener('hashchange', router);
        document.addEventListener('DOMContentLoaded', () => {
            auth.onAuthStateChanged(user => {
                updateModeratorUI(user);
            });
            
            router();
        });
    </script>
</body>
                    </html>
